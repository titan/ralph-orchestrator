# E2E Test Orchestration Config
#
# This config is used when Ralph orchestrates E2E test development.
# It uses a separate scratchpad to avoid polluting the main scratchpad
# or interfering with E2E test workspaces.
#
# Usage:
#   ralph run -c ralph.e2e.yml -p ".ralph/specs/e2e-test-fixes.spec.md"

event_loop:
  prompt_file: "PROMPT.md"
  completion_promise: "LOOP_COMPLETE"
  starting_event: "build.start"
  max_iterations: 100
  max_runtime_seconds: 14400
  checkpoint_interval: 5

cli:
  backend: "kiro"
  prompt_mode: "arg"

core:
  scratchpad: ".ralph/agent/e2e-scratchpad.md"  # Isolated from main scratchpad
  specs_dir: ".ralph/specs/"
  guardrails:
    - "Fresh context each iteration ‚Äî scratchpad is memory"
    - "Verification is mandatory ‚Äî tests/typecheck/lint must pass"
    - "YAGNI ruthlessly ‚Äî no speculative features"
    - "KISS always ‚Äî simplest solution that works"

hats:
  planner:
    name: "üìã Planner"
    description: "Detects input type and bootstraps implementation context from PDD output, code tasks, or descriptions."
    triggers: ["build.start"]
    publishes: ["tasks.ready"]
    instructions: |
      ## PLANNER MODE ‚Äî Bootstrap Implementation Context

      You detect the input type and set up the implementation context.
      The prompt tells you what to implement ‚Äî it could be a PDD directory, a code task file, or a description.

      ### Input Detection

      Analyze the prompt to determine input type:

      **Type 1: PDD Output Directory**
      - Prompt looks like a path: `.ralph/specs/my-feature` or `.ralph/specs/my-feature/`
      - Directory contains `.ralph/tasks/` subdirectory with `.code-task.md` files
      - May also have `design.md`, `plan.md`, `context.md`

      **Type 2: Single Code Task File**
      - Prompt is a path ending in `.code-task.md`
      - Example: `.ralph/tasks/add-verbose-flag.code-task.md`

      **Type 3: Rough Description**
      - Prompt is plain text describing what to implement
      - Example: "Add a --verbose flag to the CLI that enables debug logging"

      ### Process by Input Type

      **For PDD Directory:**
      1. Verify directory exists and has `.ralph/tasks/` subdirectory
      2. List all `.code-task.md` files in `.ralph/tasks/`
      3. Derive `task_name` from directory name (e.g., `.ralph/specs/my-feature` ‚Üí `my-feature`)
      4. Write scratchpad with frontmatter:
         ```markdown
         ---
         task_name: {task_name}
         spec_dir: {prompt path}/
         input_type: pdd
         status: implementation
         current_hat: planner
         ---

         ## Implementation Context

         Input: PDD output directory at {path}
         Tasks found: {count} code tasks
         Design: {spec_dir}/design.md (if exists)

         ## Task Queue
         {list of pending .code-task.md files}
         ```
      5. Publish `tasks.ready`

      **For Single Code Task:**
      1. Verify file exists and is readable
      2. Derive `task_name` from filename (e.g., `add-verbose-flag`)
      3. Write scratchpad:
         ```markdown
         ---
         task_name: {task_name}
         spec_dir: null
         input_type: single_task
         status: implementation
         current_hat: planner
         task_file: {prompt path}
         ---

         ## Implementation Context

         Input: Single code task at {path}

         ## Task Queue
         - [ ] {task_file}
         ```
      4. Publish `tasks.ready`

      **For Rough Description:**
      1. Derive `task_name` from description (kebab-case, e.g., "Add verbose flag" ‚Üí `add-verbose-flag`)
      2. Write scratchpad:
         ```markdown
         ---
         task_name: {task_name}
         spec_dir: null
         input_type: description
         status: implementation
         current_hat: planner
         ---

         ## Implementation Context

         Input: Direct description
         Description: {prompt}

         ## Task Queue
         - [ ] Implement: {prompt}
         ```
      3. Publish `tasks.ready`

      ### Event Format
      ```bash
      ralph emit "tasks.ready" "input_type: {pdd|single_task|description}, task_name: {task_name}, tasks: {count or 1}"
      ```

      ### Constraints
      - You MUST NOT start implementing because implementation belongs to the Builder
      - You MUST verify paths exist before assuming they're valid
      - You MUST write the scratchpad with proper frontmatter for downstream hats
      - You SHOULD fail gracefully if PDD directory is missing expected files

  builder:
    name: "‚öôÔ∏è Builder"
    description: "TDD implementer following RED ‚Üí GREEN ‚Üí REFACTOR cycle, one task at a time."
    triggers: ["tasks.ready", "validation.failed", "task.complete"]
    publishes: ["implementation.ready", "build.blocked", "task.complete"]
    instructions: |
      ## BUILDER MODE ‚Äî TDD Implementation

      You implement one task at a time using Test-Driven Development.

      ### TDD Cycle

      **RED ‚Üí GREEN ‚Üí REFACTOR**

      1. **RED**: Write a failing test
      2. **GREEN**: Write minimal code to pass
      3. **REFACTOR**: Clean up while keeping tests green

      ### Task Selection

      Read scratchpad to find the next pending task:
      - `[ ]` = pending
      - `[x]` = done
      - `[~]` = cancelled

      Pick the first `[ ]` task.

      ### Implementation Process

      1. Read the task file (if it's a `.code-task.md`)
      2. Write a failing test
      3. Run tests ‚Üí verify RED
      4. Write minimal implementation
      5. Run tests ‚Üí verify GREEN
      6. Refactor if needed
      7. Update scratchpad: mark task `[x]`
      8. Publish event

      ### Event Format

      **After completing a task:**
      ```bash
      ralph emit "task.complete" "task: {task_name}, tests: {pass/fail}"
      ```

      **After all tasks complete:**
      ```bash
      ralph emit "implementation.ready" "tests: pass, lint: pass, typecheck: pass"
      ```

      **If blocked:**
      ```bash
      ralph emit "build.blocked" "reason: {why blocked}"
      ```

      ### Constraints
      - You MUST run tests after each change
      - You MUST NOT skip the RED phase
      - You MUST write minimal code (YAGNI)
      - You MUST keep tests passing (GREEN)

  validator:
    name: "‚úÖ Validator"
    description: "Exhaustive quality gate with YAGNI/KISS checks and manual E2E testing."
    triggers: ["implementation.ready"]
    publishes: ["validation.passed", "validation.failed"]
    instructions: |
      ## VALIDATOR MODE ‚Äî Quality Gate

      You verify the implementation meets all quality standards.

      ### Validation Checklist

      **1. Automated Checks**
      - [ ] `cargo test` passes
      - [ ] `cargo clippy` passes
      - [ ] `cargo fmt --check` passes
      - [ ] `cargo build` succeeds

      **2. YAGNI Check**
      - [ ] No speculative features
      - [ ] No unused code
      - [ ] No premature abstractions

      **3. KISS Check**
      - [ ] Simplest solution that works
      - [ ] No unnecessary complexity
      - [ ] Clear and readable

      **4. Manual E2E Test**
      - [ ] Execute E2E scenario from spec
      - [ ] Verify expected behavior
      - [ ] Document results

      ### Event Format

      **If validation passes:**
      ```bash
      ralph emit "validation.passed" "automated: pass, yagni: pass, kiss: pass, e2e: pass"
      ```

      **If validation fails:**
      ```bash
      ralph emit "validation.failed" "issues: [{issue 1}, {issue 2}]"
      ```

      ### Constraints
      - You MUST run all automated checks
      - You MUST verify YAGNI/KISS principles
      - You MUST execute manual E2E tests
      - You MUST document failures clearly

  committer:
    name: "üì¶ Committer"
    description: "Creates conventional commits after validation passes."
    triggers: ["validation.passed"]
    publishes: ["commit.complete"]
    instructions: |
      ## COMMITTER MODE ‚Äî Create Conventional Commit

      You create a conventional commit after validation passes.

      ### Commit Format

      ```
      <type>(<scope>): <subject>

      <body>

      <footer>
      ```

      **Types:**
      - `feat`: New feature
      - `fix`: Bug fix
      - `refactor`: Code refactoring
      - `test`: Test changes
      - `docs`: Documentation
      - `chore`: Maintenance

      ### Process

      1. Review changes with `git status` and `git diff`
      2. Stage changes with `git add`
      3. Create commit with conventional format
      4. Publish event

      ### Event Format
      ```bash
      ralph emit "commit.complete" "commit: {short hash}, message: {commit subject}"
      ```

      ### Constraints
      - You MUST use conventional commit format
      - You MUST include meaningful commit message
      - You MUST stage all relevant changes
